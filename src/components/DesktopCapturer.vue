<template lang="pug">
</template>

<script>
import { Resolutions, getDimensionsForResolution } from '@/utils/enums/Resolutions';

export default {
  name: 'DesktopCapturer',
  props: {
    enableVideo: Boolean,
    enableAudio: Boolean,
    enableMic: Boolean,
    resolution: {
      type: String,
      default: Resolutions.FitScreen,
    },
  },
  data() {
    return {
      isSharing: false,
    };
  },
  watch: {
    isSharing(newValue) {
      this.$emit('isSharing', newValue);
    },
  },
  beforeDestroy() {
    this.stopStream();
  },
  methods: {
    setDefaults() {
      this.$emit('setDefaults');
      this.isSharing = false;
    },
    startStream() {
      this.setDefaults();
      this.isSharing = true;
      this.captureDesktop();
    },
    stopStream() {
      this.isSharing = false;

      // SM: post Vue migration, what previously ran in captureDesktop is instead in setDefaults
      // this.captureDesktop();
      this.setDefaults();
    },
    captureDesktop() {
      this.onAccessApproved();
    },
    onAccessApproved() {
      // console.log(navigator.mediaDevices.getSupportedConstraints());
      let dimensions = '';
      
      if(!this.enableVideo) {
        dimensions = getDimensionsForResolution('Fit144p');
      } else {
        dimensions = getDimensionsForResolution(this.resolution);
      }
      
      let constraints = {
        video: {
          // TODO: displaySurface support is waiting on browser support
          // https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints/displaySurface
          // displaySurface: ["application", "browser", "monitor", "window"],
          width: { ideal: dimensions.width },
          height: { ideal: dimensions.height },
        },
        audio: {
          autoGainControl: false,
          echoCancellation: false,
          noiseSuppression: false,
        },
      };

      const startMicCapture = async () => {
        let captureMicStream;
        try {
          captureMicStream = await navigator.mediaDevices.getUserMedia(
            {
              audio: true,
              video: false,
            },
          );
        } catch (err) {
          console.error('Error getting microphone', err);
          alert('Your browser denied microphone access');
          // this.setDefaults();
        }
        return captureMicStream;
      };

      const startScreenCapture = async () => {
        let captureStream;
        try {
          captureStream = await navigator.mediaDevices.getDisplayMedia(
            constraints,
          );
        } catch (err) {
          this.setDefaults();
        }
        return captureStream;
      };

      const startCapturing = async () => {
        let micStream = null;
        if (this.enableMic === true) {
          micStream = await startMicCapture();
        }
        if (this.enableMic === true && !micStream) {
          return;
        }
        let stream = await startScreenCapture();
        // console.log(stream.getTracks()[0].getCapabilities());
        // console.log(stream.getTracks()[0].getSettings());

        // Remove the video track from the source stream if audio only
        if (
          !this.enableVideo &&
          stream.getVideoTracks().length > 0
        ) {
          stream.removeTrack(
            stream.getVideoTracks()[0],
          );
        }
        if (stream.getVideoTracks().length > 0) {
          stream.containsVideo = true;
        }
        if (this.enableAudio && stream.getAudioTracks().length === 0) {
          alert('Make sure to check the "Share audio" box in Google Chrome or Microsoft Edge');
          this.$nextTick(() => {
            this.stopStream();
          });
          return;
        }
        if (stream.getAudioTracks().length > 0) {
          stream.containsAudio = true;
        }
        if (micStream) {
          stream.addTrack(micStream.getAudioTracks()[0]);
          stream.containsMic = true;
        }
        this.gotStream(stream);
      };
      startCapturing();
    },
    gotStream(stream) {
      if (!stream) {
        this.setDefaults();
        return;
      }

      stream.addEventListener('inactive', () => {
        this.setDefaults();
      });

      this.addStreamStopListener(stream, () => {
        this.setDefaults();
      });

      this.$emit('gotStream', stream);
    },
    addStreamStopListener(stream, callback) {
      var streamEndedEvent = 'ended';
      if ('oninactive' in stream) {
        streamEndedEvent = 'inactive';
      }
      stream.addEventListener(
        streamEndedEvent,
        function() {
          callback();
          callback = function() {};
        },
        false,
      );
      stream.getAudioTracks().forEach(function(track) {
        track.addEventListener(
          streamEndedEvent,
          function() {
            callback();
            callback = function() {};
          },
          false,
        );
      });
      stream.getVideoTracks().forEach(function(track) {
        track.addEventListener(
          streamEndedEvent,
          function() {
            callback();
            callback = function() {};
          },
          false,
        );
      });
    },
  },
};
</script>
